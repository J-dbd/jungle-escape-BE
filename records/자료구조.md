# `backEndPlayer`자료구조

### [후보1] 객체를 사용한 방식

각 클라이언트의 socket.io ID를 키로 사용하여 플레이어 데이터를 저장

```javascript
backEndPlayers:  {
  DYEAluKiQq07zGNvAAAD: { //socket.io의 id
    pos: {
      x: -2.0690038204193115,
      y: 0.45941194891929626,
      z: 1.4890671968460083
    },
    rot: { x: 0, y: 0, z: 0, w: 1 },
    sequenceNumber: 0
  },
  dV3jvm6jpxsBX_SgAAAF: {
    pos: {
      x: -2.0690038204193115,
      y: 0.45941194891929626,
      z: 1.4890671968460083
    },
    rot: { x: 0, y: 0, z: 0, w: 1 },
    sequenceNumber: 0
  }
}
```

### [후보2] 배열(array)을 사용한 방식

각 플레이어를 객체로 표현하고, 이들을 배열에 저장

```javascript
[
   {id: DYEAluKiQq07zGNvAAAD,
    pos: {
      x: -2.0690038204193115,
      y: 0.45941194891929626,
      z: 1.4890671968460083
    },
    rot: { x: 0, y: 0, z: 0, w: 1 },
    sequenceNumber: 0
  },
{
    id: dV3jvm6jpxsBX_SgAAAF
    pos: {
      x: -2.0690038204193115,
      y: 0.45941194891929626,
      z: 1.4890671968460083
    },
    rot: { x: 0, y: 0, z: 0, w: 1 },
    sequenceNumber: 0
  }
]
```

## 두 방식 장단점

### 객체 방식

장점:

- 빠른 검색 및 접근: 플레이어의 socket.io ID로 직접 접근할 수 있으므로, 특정 플레이어의 데이터를 조회하거나 수정할 때 매우 효율적입니다.
- 중복 방지: 키(ID)의 고유성으로 인해 같은 플레이어에 대한 중복 데이터를 방지할 수 있습니
- 직관적 구조: 플레이어의 ID를 키로 사용함으로써, 데이터 구조를 이해하고 사용하기가 비교적 간단합니다.

단점:

- 순서 보장 불가: 객체는 속성들의 순서를 보장하지 않습니다. 플레이어들을 특정 순서대로 관리하고자 할 때 불리합니다.
- 유연성 부족: 플레이어 데이터를 필터링하거나 정렬하는 것이 배열에 비해 덜 직관적이고 복잡할 수 있습니다.

### 배열 방식

장점:

- 순서 보장: 배열은 요소들의 순서를 보장합니다. 이는 플레이어들의 목록을 순차적으로 처리하거나 순서에 의미를 부여할 때 유리합니다.
- 유연한 데이터 처리: 배열 메서드(filter, map, sort 등)를 사용하여 데이터를 쉽게 처리하고 관리할 수 있습니다.

  단점:

- 검색 효율성 저하: 특정 플레이어를 검색할 때 전체 배열을 순회해야 하므로, 객체 방식에 비해 검색 속도가 느릴 수 있습니다.
- 중복 데이터 관리: 배열에서는 중복된 데이터를 관리하는 것이 더 복잡할 수 있으며, 고유성을 보장하기 위한 추가적인 로직이 필요할 수 있습니다.

* 순서 보장보다는 빠른 접근이 필요해보임.
